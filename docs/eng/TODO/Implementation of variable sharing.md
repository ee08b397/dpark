DPark中除RDD之外还有一个很重要的概念就是共享变量，目前实现的共享变量有两种类型：广播变量以及累加器。在此简单介绍一下这两种共享变量的实现，以使得开发者能够更好地使用共享变量并根据自己的需要支持一些别的共享变量类型。

#### 广播变量

在DPark中，当用户编写的程序调用了RDD的`map`, `filter`等变换的时候，会传递给这些变换一个函数，DPark会在实际运行的时候将这个函数所需要的闭包给序列化后也传递到相应的计算节点中，那么就可以在函数中使用函数所在域的变量、函数等。当时如果有一个大的只读数据集需要在闭包中被使用，每一次序列化然后传递到相应节点后反序列化的成本会变得很高，所以DPark提供了广播变量特性来使得用户可以将其一次性传递到所有的节点上，在之后的闭包传递中传递对应的广播后的变量。目前实现的广播算法有分布式文件系统广播算法以及树型广播算法。

对于分布式文件系统广播算法(`broadcast.FileBroadcast`)，当用户为变量`v`创建一个广播变量`bv`的时候，DPark会为其创建一个唯一的广播ID，并将变量`v`序列化后存储到分布式文件系统的一个文件中，当需要传递闭包的时候，DPark会将`bv`而不是`v`本身序列化后传递过去，而广播变量`bv`的序列化结果就是这个唯一的广播ID，在用户通过`bv.value`使用`v`本身的时候，DPark首先会检查`v`是否在本地的缓存中，如果不在，会将对应的文件反序列化并提供给计算节点使用。

对于树型广播算法(`broadcast.TreeBroadcast`)，当创建广播变量`bv`的时候，DPark也会为其创建一个唯一的广播ID，但是不同于分布式文件系统广播算法，DPark并不会将`v`序列化后存储到文件中，会利用zeromq在master上绑定一个端口，在worker中需要读取真实值的时候，如果本地缓存没有的话，那么将会向master去请求数据，而当一个worker已经获得数据之后，它就可以参与传播，把数据传给其他的worker，每个进程可以传播给N个其他进程，所以是传播的过程是一颗N叉树。

> 关于两种算法之间的比较：通常而言，树型广播算法会比分布式文件系统广播算法要快一些，原因主要有：树型算法中只有内存访问和网络IO，而文件系统算法中还需要进行磁盘操作，并且其网络IO也会需要经过更多层次；同时树型算法中，整体数据会被分割为一些块，所以即使一个节点还没有获得所有的数据，它还是可以参与到广播之中，将已获得的数据传递给下一个节点，广播的时间会相对缩短一些。

> 在Spark中目前还支持了P2P的广播算法，DPark在未来的升级版本中也会继续加入更好的广播算法。

#### 累加器

累加器在创建的时候，需要提供一个`accumulator.AccumulatorParam`的对象作为参数，这个类当中有两个值代表累加器的0值以及加法的定义，例如数值型累加器的0值就是0，然后加法就是普通的数值加法；而对于列表型累加器来说，0值就是`[]`，加法则是`extend`函数。当累加器被创建的时候，会为其分配一个唯一的累加器ID，而当其随着任务被传递到计算节点的时候，会在节点中创建出一个值为0的副本，在该任务中对其进行的任何操作实际上都只是在对这个副本进行操作，对主程序中的累加器并没有影响，只有当任务结束返回的时候，DPark的调度器会将该计算节点中的这个副本和主程序中的累加器进行合并，在所有任务完成之后，才能得到正确的值。

由此实现可以得知，在计算过程中获得的累加器的值实际上只是当前任务的值而不是所有任务的值的和，而且只有当RDD的操作被调用的时候，之前在变换中希望执行的关于累加器的操作才会被真正执行，例如：

    acc = ctx.accumulator(0)
    def sum(x):
        x = int(x)
        acc.add(x)
        return x
    rdd = rdd.map(sum)
    print acc.value
    rdd.count()
    print acc.value

在上面这个程序中，第一个输出将会是0，而第二个输出才会是正确的值。

